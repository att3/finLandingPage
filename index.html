<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fin - Your Financial Assistant</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    body, html {
      height: 100%;
      width: 100%;
      background-color: #0e0e12;
      color: #ffffff;
      overflow-x: hidden;
    }
    
    .background-gradient {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 50% 50%, rgba(52, 211, 153, 0.1), rgba(14, 14, 18, 0) 70%);
      z-index: -1;
      opacity: 0.8;
      animation: pulse-bg 8s infinite ease-in-out;
    }
    
    @keyframes pulse-bg {
      0% { opacity: 0.4; }
      50% { opacity: 0.8; }
      100% { opacity: 0.4; }
    }
    
    .app-layout {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      max-width: 1200px;
      margin:auto;
    }
    
    .header-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1rem;
    }
    
    .graph-section {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding-top: 2rem;
      padding-bottom: 5rem;
    }
    
    .cta-section {
      margin-top: 2.5rem;
      margin-bottom: 3.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .logo-container {
      margin-bottom: 1.25rem;
      position: relative;
      margin-top: 75px;
    }
    
    .logo {
      font-size: 4rem;
      font-weight: 800;
      background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      position: relative;
      display: inline-block;
      filter: drop-shadow(0 0 15px rgba(52, 211, 153, 0.3));
    }
    
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    
    .logo::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
      filter: blur(25px);
      z-index: -1;
      opacity: 0.2;
      animation: pulse 3s infinite ease-in-out;
    }
    
    .logo-dot {
      width: 8px;
      height: 8px;
      background: #34d399;
      border-radius: 50%;
      position: absolute;
      right: -12px;
      top: 15px;
      box-shadow: 0 0 15px rgba(52, 211, 153, 0.8);
    }
    
    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      margin-bottom: 1.25rem;
      text-align: center;
    }
    
    .input-container {
      width: 100%;
      max-width: 550px;
      position: relative;
      margin-top: 1rem;
      margin-bottom: 1rem;
    }
    
    .search-input {
      width: 100%;
      padding: 0.9rem 3rem 0.9rem 1.25rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 100px;
      background-color: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      color: #ffffff;
      font-size: 0.95rem;
      transition: all 0.2s ease;
      outline: none;
    }
    
    .search-input:focus {
      border-color: #34d399;
      box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.2);
    }
    
    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .send-button {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background-color: transparent;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .send-button:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .send-button svg {
      width: 16px;
      height: 16px;
    }
    
    .subtitle {
      font-size: 0.95rem;
      line-height: 1.5;
      max-width: 550px;
      text-align: center;
      margin-top: 1rem;
      margin-bottom: 13.75rem;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .hero-text {
      font-size: 2.2rem;
      font-weight: 800;
      background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      position: relative;
      display: inline-block;
      filter: drop-shadow(0 0 10px rgba(52, 211, 153, 0.2));
      font-family: 'Montserrat', sans-serif;
      letter-spacing: -0.02em;
      line-height: 1.2;
      margin-top: 0.5rem;
    }
    
    @keyframes hero-glow {
      0% { opacity: 0.4; }
      50% { opacity: 0.8; }
      100% { opacity: 0.4; }
    }
    
    .hero-text::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
      filter: blur(25px);
      z-index: -1;
      opacity: 0.3;
      animation: hero-glow 4s infinite ease-in-out;
    }
    
    #graph-container {
      width: 100%;
      height: 550px;
      position: relative;
    }
    
    .question-tooltip {
      position: fixed;
      background-color: rgba(14, 14, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 0.6rem 1.25rem;
      border-radius: 8px;
      font-size: 1rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease, transform 0.2s ease;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      max-width: 320px;
      text-align: center;
      backdrop-filter: blur(10px);
      z-index: 100;
      transform: translateY(-30px);
    }
    
    .cta-text {
      text-align: center;
      color: rgba(255, 255, 255, 0.9);
      font-size: 1.5rem;
      font-weight: 400;
      margin-bottom: 1.5rem;
      max-width: 400px;
    }
    
    .open-fin-button {
      padding: 0.75rem 2.5rem;
      background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
      border: none;
      border-radius: 100px;
      color: white;
      font-weight: 600;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      position: relative;
      overflow: hidden;
    }
    
    .open-fin-button:hover {
      transform: translateY(-3px) scale(1.03);
      box-shadow: 0 8px 30px rgba(59, 130, 246, 0.4);
    }
    
    .open-fin-button::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: rgba(255, 255, 255, 0.1);
      transform: rotate(45deg);
      z-index: 1;
      transition: all 0.6s ease;
      opacity: 0;
    }
    
    .open-fin-button:hover::before {
      animation: button-shine 1.5s ease-out infinite;
      opacity: 1;
    }
    
    @keyframes button-shine {
      0% {
        left: -50%;
        opacity: 0.8;
      }
      100% {
        left: 150%;
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div class="background-gradient"></div>
  <div id="root"></div>

  <script type="text/babel">
    // Main component
    const FinApp = () => {
      const [hoveredQuestion, setHoveredQuestion] = React.useState(null);
      const [tooltipPosition, setTooltipPosition] = React.useState({ x: 0, y: 0 });
      const tooltipRef = React.useRef(null);
      
      // Financial questions
      const questions = [
        // Basic financial concepts
        "What are bonds?",
        "How can I save money?",
        "Explain compound interest",
        "What is inflation?",
        "How do ETFs work?",
        "What is dollar cost averaging?",
        "How to read financial statements?",
        "Explain P/E ratio",
        "What is market capitalization?",
        "Difference between stocks and bonds?",
        
        // Personal finance
        "Create a budget",
        "How to track expenses?",
        "Analyze my transactions",
        "Have I paid my rent?",
        "How much money do I have left?",
        "Where am I spending too much?",
        "How to increase my savings rate?",
        "Best ways to reduce monthly expenses?",
        "Am I saving enough for retirement?",
        "How to improve credit score?",
        "Should I pay off debt or invest?",
        "How to automate my finances?",
        
        // Investments
        "Invest in stocks or crypto?",
        "Should I buy individual stocks?",
        "How to start investing?",
        "Best long-term investment strategy?",
        "What is index investing?",
        "How to diversify my portfolio?",
        "What's a good asset allocation?",
        "When should I sell investments?",
        "How to invest during inflation?",
        "What are dividend stocks?",
        "Best tax-efficient investments?",
      ];
      
      // Set focus on load
      React.useEffect(() => {
        // Auto-focus the input field when the page loads
        const inputElement = document.querySelector('.search-input');
        if (inputElement) {
          setTimeout(() => {
            inputElement.focus();
          }, 100);
        }
      }, []);
      
      // Setup 3D graph
      React.useEffect(() => {
        // Get graph container
        const graphContainer = document.getElementById('graph-container');
        if (!graphContainer) return;
        
        // Variable for time tracking
        let time = 0;
        
        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.userData = { pauseRotation: false };
        
        // Camera setup for larger graph
        const camera = new THREE.PerspectiveCamera(35, graphContainer.clientWidth / graphContainer.clientHeight, 0.1, 1000);
        camera.position.z = 8;
        
        // Renderer setup with size limits
        const renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true
        });
        
        // Limit renderer size for performance
        const maxWidth = Math.min(graphContainer.clientWidth, 1200);
        const maxHeight = Math.min(graphContainer.clientHeight, 800);
        renderer.setSize(maxWidth, maxHeight);
        renderer.setClearColor(0x0e0e12, 0);
        graphContainer.appendChild(renderer.domElement);
        
        // Create center node
        const centerGeometry = new THREE.SphereGeometry(0.03, 32, 32);
        const centerMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x34d399,
          transparent: true,
          opacity: 0.9
        });
        const centerNode = new THREE.Mesh(centerGeometry, centerMaterial);
        scene.add(centerNode);
        
        // Glow effect for center
        const glowGeometry = new THREE.SphereGeometry(0.05, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0x34d399,
          transparent: true,
          opacity: 0.2
        });
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glowMesh);
        
        // Create shared materials for better performance
        const normalMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x6b7280,
          transparent: true,
          opacity: 0.6
        });
        
        const activeMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x34d399,
          transparent: true,
          opacity: 1
        });
        
        // Create shared line material
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0x34d399,
          transparent: true,
          opacity: 0.1
        });
        
        // Create nodes - limited number for performance
        const nodeCount = Math.min(questions.length, 30);
        const nodeObjects = [];
        const nodeGeometry = new THREE.SphereGeometry(0.04, 16, 16);
        const lines = [];
        
        // Create node distribution
        for (let i = 0; i < nodeCount; i++) {
          // Position nodes using Fibonacci distribution
          const offsetAngle = i * 137.5 * (Math.PI / 180);
          const vectorY = 1 - (i / (nodeCount - 1)) * 2;
          const radius = 3.8;
          
          const radiusAtY = Math.sqrt(1 - vectorY * vectorY);
          const x = Math.cos(offsetAngle) * radiusAtY * radius;
          const y = vectorY * radius * 0.8;
          const z = Math.sin(offsetAngle) * radiusAtY * radius;
          
          // Create node with cloned material for individual manipulation
          const node = new THREE.Mesh(nodeGeometry, normalMaterial.clone());
          node.position.set(x, y, z);
          node.userData = {
            index: i,
            originalPosition: { x, y, z },
            hovering: false
          };
          
          // Create line connecting to center
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(x, y, z)
          ]);
          const line = new THREE.Line(lineGeometry, lineMaterial.clone());
          
          // Add to scene
          scene.add(node);
          scene.add(line);
          
          // Store references
          nodeObjects.push(node);
          lines.push(line);
        }
        
        // Optimization state
        const renderState = { needsUpdate: true };
        
        // Raycaster for mouse interactions
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Handle mouse movements
        const handleMouseMove = (event) => {
          // Signal that we need to update the render
          renderState.needsUpdate = true;
          
          // Get container position
          const rect = graphContainer.getBoundingClientRect();
          
          // Calculate normalized mouse position
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          // Update raycaster with mouse position
          raycaster.setFromCamera(mouse, camera);
          
          // Find intersected objects
          const intersects = raycaster.intersectObjects(nodeObjects);
          
          // Reset all nodes to normal state
          nodeObjects.forEach(node => {
            node.material.color.set(0x6b7280);
            node.material.opacity = 0.6;
            node.scale.set(1, 1, 1);
            node.userData.hovering = false;
          });
          
          // Reset all lines
          lines.forEach(line => {
            line.material.opacity = 0.05;
          });
          
          // If we're hovering over a node
          if (intersects.length > 0) {
            // Get the first intersected node
            const node = intersects[0].object;
            
            // Highlight the node
            node.material.color.set(0x34d399);
            node.material.opacity = 1;
            node.scale.set(1.3, 1.3, 1.3);
            node.userData.hovering = true;
            
            // Find and highlight its line
            const nodeIndex = nodeObjects.indexOf(node);
            if (nodeIndex >= 0 && nodeIndex < lines.length) {
              lines[nodeIndex].material.opacity = 0.8;
            }
            
            // Show tooltip with question
            const questionText = questions[nodeIndex];
            setHoveredQuestion(questionText);
            
            // Position tooltip at mouse position
            setTooltipPosition({ 
              x: event.clientX, 
              y: event.clientY 
            });
            
            // Pause rotation when hovering
            scene.userData.pauseRotation = true;
          } else {
            // Hide tooltip when not hovering
            setHoveredQuestion(null);
            
            // Resume rotation
            scene.userData.pauseRotation = false;
          }
        };
        
        // Add mouse move listener
        graphContainer.addEventListener('mousemove', handleMouseMove);
        
        // Handle window resize
        const handleResize = () => {
          // Update camera
          camera.aspect = graphContainer.clientWidth / graphContainer.clientHeight;
          camera.updateProjectionMatrix();
          
          // Update renderer size
          const maxWidth = Math.min(graphContainer.clientWidth, 1200);
          const maxHeight = Math.min(graphContainer.clientHeight, 800);
          renderer.setSize(maxWidth, maxHeight);
          
          // Force update
          renderState.needsUpdate = true;
        };
        
        // Add resize listener
        window.addEventListener('resize', handleResize);
        
        // Animation loop with optimization
        let animationId = null;
        
        const animate = () => {
          // Request next frame
          animationId = requestAnimationFrame(animate);
          
          // Only render when needed
          if (renderState.needsUpdate) {
            // Update time
            time += 0.005;
            
            // Animate center node
            const pulseScale = 1 + 0.05 * Math.sin(time * 2);
            centerNode.scale.set(pulseScale, pulseScale, pulseScale);
            glowMesh.scale.set(pulseScale * 1.2, pulseScale * 1.2, pulseScale * 1.2);
            
            // Only rotate when not hovering
            if (!scene.userData.pauseRotation) {
              // Very slow rotation
              scene.rotation.y += 0.0002;
              
              // Update render flag
              renderState.needsUpdate = true;
              
              // Update node positions
              nodeObjects.forEach((node, i) => {
                if (!node.userData.hovering) {
                  const { originalPosition } = node.userData;
                  node.position.set(originalPosition.x, originalPosition.y, originalPosition.z);
                }
                
                // Update line connections
                if (i < lines.length) {
                  const linePoints = [
                    new THREE.Vector3(0, 0, 0),
                    node.position.clone()
                  ];
                  
                  lines[i].geometry.setFromPoints(linePoints);
                }
              });
            } else {
              // Don't need continuous updates when paused
              renderState.needsUpdate = false;
            }
            
            // Render the scene
            renderer.render(scene, camera);
          }
        };
        
        // Start animation
        animate();
        
        // Clean up on unmount
        return () => {
          // Cancel animation
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          
          // Remove event listeners
          window.removeEventListener('resize', handleResize);
          if (graphContainer) {
            graphContainer.removeEventListener('mousemove', handleMouseMove);
          }
          
          // Dispose of geometries
          if (nodeGeometry) nodeGeometry.dispose();
          if (centerGeometry) centerGeometry.dispose();
          if (glowGeometry) glowGeometry.dispose();
          
          // Dispose of materials
          if (normalMaterial) normalMaterial.dispose();
          if (activeMaterial) activeMaterial.dispose();
          if (lineMaterial) lineMaterial.dispose();
          if (centerMaterial) centerMaterial.dispose();
          if (glowMaterial) glowMaterial.dispose();
          
          // Clean up nodes and lines
          nodeObjects.forEach(node => {
            if (node.geometry) node.geometry.dispose();
            if (node.material) node.material.dispose();
          });
          
          lines.forEach(line => {
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
          });
          
          // Clean up renderer
          if (renderer) {
            renderer.dispose();
            if (graphContainer.contains(renderer.domElement)) {
              graphContainer.removeChild(renderer.domElement);
            }
          }
        };
      }, []);
      
      return (
        <div className="app-layout">
          <div className="header-section">
            <div className="logo-container">
              <div className="logo">Fin</div>
              <div className="logo-dot"></div>
            </div>
            
            <h1>Your Financial Assistant</h1>
            
            <div className="input-container">
              <input 
                type="text" 
                className="search-input" 
                placeholder="Ask Fin anything..."
              />
              <button className="send-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#888888" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <line x1="5" y1="12" x2="19" y2="12"></line>
                  <polyline points="12 5 19 12 12 19"></polyline>
                </svg>
              </button>
            </div>
            
            <p className="subtitle">
              Fin is your personal financial companion, always ready to help. Ask anything about investments, budgeting, spending, or financial planning to get AI-powered insights tailored just for you.
            </p>
            
            <div className="hero-text">Master Your Financial Universe</div>
          </div>
          
          <div className="graph-section">
            <div 
              id="graph-container"
              style={{ 
                width: '100%', 
                height: '550px',
                position: 'relative'
              }}
            ></div>
            
            {hoveredQuestion && (
              <div 
                className="question-tooltip" 
                ref={tooltipRef}
                style={{
                  opacity: hoveredQuestion ? 1 : 0,
                  left: tooltipPosition.x,
                  top: tooltipPosition.y
                }}
              >
                {hoveredQuestion}
              </div>
            )}
            
            <div className="cta-section">
              <p className="cta-text">
                Ready to take control of your financial future?
              </p>
              <button className="open-fin-button">
                Start Now
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Render the app
    ReactDOM.render(<FinApp />, document.getElementById('root'));
  </script>
</body>
</html>
